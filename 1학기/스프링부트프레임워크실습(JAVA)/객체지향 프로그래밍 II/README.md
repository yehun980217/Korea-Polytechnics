<h1>인스턴스 변수</h1>
<ul>
  <li>클래스의 속성</li>
  <p>크게 인스턴스 변수와 클래스 변수로 구분할 수 있음<br>
  <strong>인스턴스 변수</strong><br>
  <code>클래스를 통해 객체를 생성해야만 공간이 할당됨</code><br>
  <strong>클래스 변수</strong><br>
  <code>클래스 자체에 공간이 있기 때문에 객체를 생성하지 않아도 됨</code></p>
  <li>인스턴스 변수</li>
  <p>객체(인스턴스)를 생성해야 비로소 사용할 수 있는 변수<br>
  <code>지금까지 사용했던 속성은 모두 인스턴스 변수임</code><br>
  <code>[예]Rabbit 클래스의 shape, x, y 속성</code>
  <code>shape, x, y 속성은 클래스 안에 존재하며 아직 공간이 할당된 상태가 아님</code><br>
  <code>클래스를 이용하여 main() 메서드에서 객체 생성</code><br>
  <code>[예] Rabbit rabbit = new Rabbit();</code><br>
  클래스에는 인스턴스 변수의 공간이 할당되어 있지 않고, 객체가 만들어져야 인스턴스 변수에 공간이 할당됨</p>
</ul>
<h1>클래스 변수</h1>
<ul>
  <li>클래스 변수</li>
  <p>클래스 안에 공간이 할당된 변수<br>
  객체에 별도의 공간이 할당되지 않고 여러 객체가 클래스 변수의 공간을 같이 사용함<br>
  속성 앞에 <code>static</code>을 붙여 클래스 변수를 생성함<br>
  <code>속성 앞에 static 키워드를 붙이면 그 속성은 클래스 자체에 공간이 생김</code><br>
  클래스 변수에 접근하는 형식 → 클래스명.클래스 변수</p>
</ul>
<h1>상속의 개념</h1>
<ul>
  <li>상속</li>
  <p>클래스는 상속(inheritance)이 가능함<br>
  <code>기존의 클래스가 가지고 있는 속성과 기능을 그대로 물려받은 새로운 클래스를 만드는 것을 의미함</code><br>
  <code>상속받은 클래스에서 속성이나 기능을 추가로 만들 수 있음</code></p>
</ul>
<h1>생성자의 상속</h1>
<ul>
  <li>슈퍼 클래스와 서브 클래스에 각각 별도의 생성자가 있는 경우</li>
  <p>슈퍼 클래스에도 생성자가 있고 서브 클래스에도 생성자가 있는 경우 슈퍼 클래스의 생성자가 먼저 실행됨<br>
  <code>토끼 클래스와 집토끼 클래스에 생성자를 만들고 집토끼 객체를 생성하기</code><br>
  ![image](https://github.com/yehun980217/Korea-Polytechnics/assets/148829925/3182402c-8137-4de8-9e6d-a085fce1b656)
</p>
</ul>
<h1>상속 방지</h1>
<ul>
  <li>private</li>
  <p>기본적으로 서브 클래스는 슈퍼 클래스의 속성과 메서드를 상속받는데, 이러한 상속을 막을 수도 있음<br>
  슈퍼 클래스의 속성 또는 메서드 앞에 private를 붙이면 상속되지 않음<br>
  [예] 토끼 클래스의 상속을 방지하기<br>
  ![image](https://github.com/yehun980217/Korea-Polytechnics/assets/148829925/c981b39f-5241-4aae-b865-2d0b147709b2)
</p>
</ul>
<h1>메서드 오버라이딩</h1>
<ul>
  <li>메서드 오버 라이딩</li>
  <p>슈퍼 클래스의 메서드를 서브 클래스에서 재정의하는 것<br>
  클래스로부터 상속받은 메서드를 무시하고 동일한 이름의 메서드를 다시 만드는 것을 의미함</p>
</ul>
<h1>추상 클래스</h1>
<ul>
  <li>추상 클래스</li>
  <p>객체로 만들 수 없는 클래스<br>
  추상 클래스를 사용하는 이유<br>
  <code>바로 객체를 만들지 않고 서브 클래스에 상속한 후 객체를 만들기 위해 추상 클래스를 사용하기 위함</code><br>
  일반적인 클래스와 달리 추상 클래스는 인스턴스를 생성할 수 없음<br>
  먼저 추상 클래스를 상속받는 서브 클래스를 만든 다음 서브 클래스의 객체를 구현해야 함<br>
  클래스를 추상 클래스로 지정하는 형식<br>
  <code>abstract class 클래스명 { 속성 및 메서드 정의 }</code></p>
  <li>추상 메서드(abstract method)</li>
  <p>내용이 없는 껍데기 메서드<br>
  추상 메서드 만드는 형식(내용이 없기 때문에 본체를 감싸는 중괄호가 없음)<br>
  <code>abstract 반환형 메서드명(매개변수);</code></p>
  <li>추상 메서드의 작동 방식</li>
  <ul>
    <li>추상 메서드의 목적</li>
    <p>상속받은 서브 클래스에서 반드시 오버라이딩하여 사용하도록 하는 것<br>
    즉, 슈퍼 클래스에서는 추상 메서드로 메서드의 껍데기를 만들어놓고 각각의 서브 클래스에서 실제 내용을 채워넣게 하는 것을 의미함</p>
    <li>추상 메서드 주의사항</li>
    <p>1. 추상 메서드가 하나라도 들어 있는 클래스는 무조건 추상 클래스로 지정해야함<br>
    2. 추상 클래스의 상속을 받은 서브 클래스는 추상 메서드를 오버라이딩하지 않으면 문법적인 오류가 발생함<br>
    <code>모든 추상 메서드를 반드시 오버라이딩하여 그 내용을 의무적으로 채워야 함</code></p>
  </ul>
</ul>
<h1>인터페이스</h1>
<ul>
  <li>인터페이스(interface)</li>
  <p>인터페이스를 사용하는 목적 중 하나는 다중 상속을 하기 위함임<br>
  추상 클래스와 비슷한 개념이지만 추상 클래스보다 더 제한적임<br>
  추상 클래스와 인터페이스의 차이점<br>
  <code>추상 클래스 : 속성, 일반 메서드, 생성자, 추상 메서드 등을 모두 가질 수 있음</code><br>
  <code>인터페이스 : 속성과 추상 메서드만 가질 수 있음. 또한 속성 앞에 static final을 붙여야함</code><br>
  인터페이스 만드는 형식 <code>interface 인터페이스명 { static final 속성, 추상 메서드 }</code></p>
</ul>
<h1>다중 상속</h1>
<p>여러 개의 슈퍼 클래스를 상속받는 것, 여러 개의 슈퍼 클래스를 통해 하나의 서브 클래스를 만드는 것을 의미함<br>
자바에서는 클래스의 다중 상속을 허용하지 않지만 인터페이스의 다중 상속은 허용함</p>
